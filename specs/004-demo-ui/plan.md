# Implementation Plan: Playable Desktop-Sim Demo UI

**Branch**: `004-demo-ui` | **Date**: 2025-09-21 | **Spec**: `specs/004-demo-ui/spec.md`
**Input**: Feature specification from `/specs/004-demo-ui/spec.md`

## Summary
Deliver a vertical-slice Godot 4 demo that blends a satirical Dutch political desktop with a lightweight
3D debate stage. The slice must let playtesters juggle political messaging, coalition trade-offs, and a
media-responsive timeline while feeling escalating pressure through copy and notifications, all runnable
offline with simple save/restore. Plan focuses on structuring systems, content stubs, telemetry, and
validation loops that uphold the constitutional principles.

## Technical Context
**Language/Version**: Godot 4.3 (GDScript) with minimal C# interop disabled  
**Primary Dependencies**: Godot UI/Control nodes, AnimationPlayer, AudioStreamPlayer, Godot 3D primitives  
**Window Shell Strategy**: Use Godot `Window` subwindows in single-window mode (`ProjectSettings.display/window/subwindows/embed_subwindows = true`) so desktop apps appear embedded; rely on `popup()` / `popup_on_parent()` for launch positions, `get_focused_window()` for focus repair, and `request_attention()` for high-priority toasts.  
**UI Theme**: Centralize typography/color/spacing tokens in a shared `Theme` resource and `merge_with()` scene-specific variants to keep the desktop consistent while allowing debate-stage tweaks.  
**Storage**: Local JSON/ConfigFile assets for scripted content and save snapshots  
**Testing**: Godot unit/integration tests via GUT + custom UX regression harness; gdUnit4 for performance probes  
**Target Platform**: macOS (Apple Silicon + Intel) desktop build; Linux for development smoke tests  
**Project Type**: single (Godot project inside `game/`)  
**Performance Goals**: 60fps desktop shell; <1s window spawn; <2s social/debate feedback; <2GB peak RAM  
**Constraints**: Offline only, canned personas, no external services, flat readable art, realistic satire tone  
**Scale/Scope**: One desktop session, five interactive apps, one debate question loop, single save slot

## Constitution Check
*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

- [x] Principle I – Godot project will enforce gdlint/gdformat in CI, run static analysis (`godot --check-only`),
  and document UI/interaction decisions in `docs/mechanics/demo-ui.md` plus inline scene comments.
- [x] Principle II – Planned test suite: unit tests for meter math, integration tests for window workflows,
  contract tests for content-driven interactions (messages/news/debate), UX regression script capturing
  window layouts, and performance guard asserting 95%+ coverage of critical systems (meters, save/load,
  desktop shell controllers).
- [x] Principle III – Establish desktop design tokens (typography, color, spacing) in shared theme, add
  accessibility hooks (keyboard focus order, narrator copy, localization keys) and record UX regression
  captures to compare layout snapshots between commits.
- [x] Principle IV – Instrument desktop and debate scene with profiler markers, schedule automated
  performance run (timesteps + memory sample) via gdUnit4, and enforce budgets in CI with threshold
  assertions; manual profiling before releases.
- [x] Operational Standards – `/spec`, `/plan`, `/tasks` will stay in lockstep; telemetry stored in
  `docs/performance/demo-ui.md`, observability hooks (local log CSV) defined during design.

## Project Structure

### Documentation (this feature)
```
specs/004-demo-ui/
├── plan.md              # This file (/plan output)
├── research.md          # Context + tone + UX references
├── data-model.md        # Meters, personas, content schemas
├── quickstart.md        # Playtest script + validation steps
├── contracts/           # Interaction/state contracts (JSON schemas)
└── tasks.md             # Generated by /tasks
```

### Source Code (repository root)
```
game/
├── project.godot
├── scenes/
│   ├── desktop/
│   │   ├── DesktopRoot.tscn
│   │   ├── Dock.tscn
│   │   └── Window*.tscn
│   └── debate/DebateStage.tscn
├── scripts/
│   ├── desktop/
│   ├── apps/
│   ├── systems/
│   └── persistence/
├── ui/
│   ├── themes/
│   └── icons/
├── data/
│   ├── personas/
│   ├── headlines/
│   └── saves/
└── audio/

# Tests and supporting assets
checks/
├── unit/
├── integration/
├── contract/
├── ui/
└── performance/
```

**Structure Decision**: Option 1 (single project) with Godot-specific folders listed above.

## Phase 0: Outline & Research
1. Run `context7` aggregation (CLI stub) to gather latest docs: constitution, code style, task workflow,
   UX conventions, prior satire references, and the Godot 4 `Window` / `Theme` API pages covering subwindow
   embedding, focus management, and theming behaviors; capture citations in `research.md`.
2. Validate satire tone and Dutch institutional references by reviewing Rijksvoorlichtingsdienst
   communication guidance (emphasis on clarity, respectful tone, accessibility) and current Dutch
   parliamentary proceedings summaries; document tone guardrails with citations.
3. Benchmark existing Godot desktop-shell patterns (window manager, drag/resize) and 3D debate staging; note
   reusable plugins vs. custom implementation trade-offs.
4. Document accessibility requirements drawn from Rijksoverheid/Rijkshuisstijl design system guidelines
   (contrast ≥4.5:1, consistent focus indicators, readable typography) and align localization key strategy.
5. Resolve open questions: save snapshot format, meter threshold copy variants, telemetry schema.

**Output**: `research.md` with decisions, rationales, alternatives, and citations for all unknowns.

## Phase 1: Design & Contracts
*Prerequisite: research.md complete*

1. **Data modelling**: Define schema for meters, personas, headlines, calendar events, save snapshot in
   `data-model.md` (fields, ranges, relationships, threshold logic).
2. **Desktop shell blueprint**: Map Control hierarchy for each window, specify docking/spawn behavior using
   `Window` nodes (`popup()` placement rules, `is_embedded()` safeguards) and shared theme hooks for chrome,
   notifications, and toasts.
3. **Interaction contracts**: For each core app + debate loop, create JSON/YAML interaction state machines in
   `contracts/` capturing inputs, outputs, and meter deltas; include validation rules and copy references.
4. **Testing blueprint**: Draft quickstart walkthrough covering desktop launch, social post, coalition choice,
   debate response, failure escalation, save/continue path. Outline automated test suites and manual probes.
5. **Telemetry plan**: Specify local logging schema (CSV/JSON) for meters, decisions, UX snapshots; map to
   performance instrumentation expectations.
6. **Accessibility & UX**: Define focus order, keyboard shortcuts, localization tokens, animation timings, and
   confirm theme tokens uphold Rijkshuisstijl contrast ratios plus Rijksvoorlichtingsdienst plain-language
   standards.
7. **Post-design Constitution check**: Re-run checklist, confirm no regressions; log adjustments if trade-offs
   arise.
8. **Agent context**: After plan approval, update Claude rules via `.specify/scripts/bash/update-agent-context.sh
   claude` with concise tech stack summary; keep manual notes under 150 lines.

**Output**: `data-model.md`, `contracts/*`, `quickstart.md`, telemetry plan appendix, updated agent context.

## Phase 2: Task Planning Approach
*Description only; `/tasks` will generate tasks.md*

**Task Generation Strategy**:
- Load `.specify/templates/tasks-template.md` baseline.
- Map Phase 1 artifacts to task categories: Setup & Tooling, Tests First, Core Implementation, Experience
  Integration, Performance & Polish.
- Each interaction contract → corresponding contract test task (checks/contract/).
- Each persona/headline/calendar schema → unit/integration tasks.
- UX/accessibility requirements → dedicated regression and validation tasks.
- Telemetry/performance plan → profiling and evidence-capture tasks.

**Ordering Strategy**:
- Maintain TDD cadence: author failing tests (unit, integration, contract, UX, performance) before gameplay
  scripts.
- Sequence: Setup tooling → tests → desktop systems → apps → debate stage → persistence → UX polish.
- Use `[P]` for tasks in distinct paths (e.g., separate test files, assets) while ensuring no shared files.

**Estimated Output**: ~28 tasks covering instrumentation and documentation alongside core implementation.

## Phase 3+: Future Implementation
- **Phase 3**: Execute tasks.md ensuring evidence captured for metrics and UX.
- **Phase 4**: Implement features with continuous profiling and telemetry verification.
- **Phase 5**: Validate via automated suites, manual quickstart, and save/continue recovery scenarios.

## Complexity Tracking
*None currently; populate only if Constitution Check requires justification.*

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|

## Progress Tracking
*Updated during execution*

**Phase Status**:
- [ ] Phase 0: Research complete (/plan command)
- [ ] Phase 1: Design complete (/plan command)
- [ ] Phase 2: Task planning complete (/plan command - describe approach only)
- [ ] Phase 3: Tasks generated (/tasks command)
- [ ] Phase 4: Implementation complete
- [ ] Phase 5: Validation passed

**Gate Status**:
- [x] Initial Constitution Check: PASS
- [ ] Post-Design Constitution Check: PASS
- [ ] All NEEDS CLARIFICATION resolved
- [ ] Complexity deviations documented

---
*Based on Constitution v2.2.0 - See `.specify/memory/constitution.md`*
